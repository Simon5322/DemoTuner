('wal_level', 'replica', 'To support WAL archiving and replication, including running read-only queries on a standby server')
('wal_level', 'minimal', 'To optimize operations like ALTER ... SET TABLESPACE, CLUSTER, CREATE TABLE, REFRESH MATERIALIZED VIEW (without CONCURRENTLY), REINDEX, TRUNCATE, generating the least WAL volume')
('wal_level', 'logical', 'To extract logical change sets from the WAL and when many tables are configured for REPLICA IDENTITY FULL and many UPDATE and DELETE statements are executed')

('fsync', 'on', 'To ensure updates are physically written to disk, ensuring reliable recovery after crashes and power failures')
('fsync', 'off', 'In certain circumstances such as initial loading of a new database cluster from a backup file, processing a batch of data after which the database will be recreated, or for a frequently recreated read-only database clone not used for failover. High-quality hardware alone is not sufficient justification.')
('fsync', 'off', 'For noncritical transactions, consider turning off synchronous_commit instead for performance benefits without the risks of data corruption')('synchronous_commit', 'remote_apply', 'synchronous_standby_names is non-empty and transaction commits need to wait for their WAL records to be processed and applied on the standby server(s) for query consistency')

('synchronous_commit', 'on', 'synchronous_standby_names is non-empty and transaction commits need to wait for their WAL records to be flushed to durable storage on the standbys for data preservation and query consistency')
('synchronous_commit', 'remote_write', 'synchronous_standby_names is non-empty and transaction commits need to wait for their WAL records to be written to file systems on the standby server(s) for data preservation but not if the standby suffers an operating-system-level crash')
('synchronous_commit', 'local', 'synchronous_standby_names is non-empty and transaction commits need to wait for local flush to disk but not for replication')('wal_sync_method', 'open_datasync', 'when fsync is off and you want to write WAL files with open() option O_DSYNC')
('wal_sync_method', 'fdatasync', 'when fsync is off and you want to call fdatasync() at each commit')
('wal_sync_method', 'fsync', 'when fsync is off and you want to call fsync() at each commit')
('wal_sync_method', 'fsync_writethrough', 'when fsync is off and you want to call fsync() at each commit, forcing write-through of any disk write cache')
('wal_sync_method', 'open_sync', 'when fsync is off and you want to write WAL files with open() option O_SYNC')('full_page_writes', 'increase', 'workload with high write activity and frequent crashes') 
('full_page_writes', 'decrease', 'workload with low write activity and stable system') 
('full_page_writes', 'off', 'workload with low write activity and system without any crashes')('wal_log_hints', 'off', 'when data checksums are not enabled and there is a need to reduce WAL volume')
('wal_compression', 'pglz', 'when there is a need to reduce WAL volume without increasing the risk of data corruption and the CPU capacity is sufficient for compression')
('wal_init_zero', 'off', 'when using Copy-On-Write (COW) file systems')('wal_recycle', 'off', 'On COW file systems')
('wal_buffers', 'increase', 'busy server with many clients committing at once')('wal_writer_delay', 'decrease', 'write-heavy workload with high transaction rate')
('wal_writer_flush_after', 'increase', 'high rate of writes and insufficient disk write throughput')('wal_skip_threshold', 'increase', 'if commits are slowing concurrent transactions')
('commit_delay', 'increase', 'if system load is high enough that additional transactions become ready to commit within the given interval')('commit_siblings', 'increase', 'highly concurrent workload with frequent commits and small transaction durations') 
('checkpoint_timeout', '[1 day]', 'workload with infrequent writes and large transaction durations, where crash recovery time is not a concern')
('checkpoint_completion_target', '0.9', 'workload with consistent I/O load and moderate checkpoint completion overhead')('checkpoint_flush_after', 'decrease', 'workload with limited memory and small shared_buffers'): In cases where the workload is larger than the shared_buffers but smaller than the OS's page cache, reducing the value of checkpoint_flush_after can improve performance by limiting the amount of dirty data in the kernel's page cache.

('checkpoint_flush_after', 'increase', 'workload with large shared_buffers and ample memory'): On the other hand, in workloads that have larger shared_buffers and ample memory, increasing the value of checkpoint_flush_after may result in greatly reduced transaction latency.

('checkpoint_warning', 'increase', 'frequent WAL segment file filling'): If checkpoints caused by the filling of WAL segment files happen closer together than the specified amount of time, increasing the value of checkpoint_warning can be helpful. This can be an indicator that the max_wal_size parameter should be raised to avoid frequent checkpoints.

('checkpoint_warning', 'disable', 'no need for warning messages'): Setting the value of checkpoint_warning to zero disables the warning messages in the server log for checkpoints caused by the filling of WAL segment files. This can be useful if there is no need for these warnings.

(Note: The recommended values for 'checkpoint_flush_after' and 'checkpoint_warning' are described as tuning trends or relative values rather than absolute values because their optimal values depend on factors such as workload size, memory capacity, and shared_buffers configuration.)
('max_wal_size', 'increase', 'heavy load or a high wal_keep_size setting')
('min_wal_size', 'increase', 'running large batch jobs')
('archive_mode', 'on or always', 'when archive recovery or standby mode is enabled')('archive_command', 'increase', 'when having a high volume of WAL files to archive')
('archive_library', 'off', 'when archiving completed WAL file segments is not required')
('archive_command', 'off', 'when temporarily disabling WAL archiving and not needing archive recovery')
('archive_library', 'on', 'when using a specified shared library for archiving')('archive_timeout', 'increase', 'low WAL traffic or slack periods with little database activity'): To limit the delay between the completion of a transaction and its safe recording in archive storage, it is recommended to increase the archive_timeout parameter. This should be done when there is low WAL traffic or slack periods with little database activity. A reasonable value for archive_timeout is usually a minute or so. However, it is important not to set a very short archive_timeout as it can lead to bloating of archive storage.
('archive_timeout', 'increase', 'slow archival process with large amounts of database activity'): If the archival process is slow and there is a large amount of database activity, increasing the archive_timeout parameter can help. By setting a higher value, the server will switch to a new segment file whenever the specified amount of time has elapsed since the last switch, regardless of the amount of database activity. This can help ensure timely archiving of transactions.

('recovery_prefetch', 'on', 'recovery with workloads that benefit from reduced I/O wait times'): Enabling the recovery_prefetch parameter can help reduce I/O wait times during recovery for workloads that benefit from prefetching blocks that will soon be needed. This is particularly useful in scenarios where the recovery process involves accessing disk blocks that are not yet in the buffer pool. 

('recovery_prefetch', 'try', 'recovery with unknown availability of posix_fadvise function'): When the availability of the posix_fadvise function is unknown, it is recommended to set the recovery_prefetch parameter to 'try'. This setting enables prefetching only if the operating system provides the posix_fadvise function. This can help improve recovery performance by utilizing prefetching if it is available.

('wal_decode_buffer_size', '[X, Y]', 'limiting wal_prefetch activity during recovery'): Adjusting the wal_decode_buffer_size parameter within the range of [X, Y] can help limit the prefetching activity during recovery. This parameter controls the amount of memory allocated for WAL decoding during the recovery process. By setting an appropriate range, the prefetching activity can be controlled to optimize the recovery process.

('maintenance_io_concurrency', '[X, Y]', 'limiting wal_prefetch activity during maintenance operations'): Configuring the maintenance_io_concurrency parameter within the range of [X, Y] can limit the prefetching activity during maintenance operations. This parameter controls the number of concurrent I/O operations that can be performed during maintenance activities. Adjusting it within the recommended range can help in optimizing the prefetching activity during maintenance operations.('wal_decode_buffer_size', 'increase', 'workload with high prefetching requirements'): As wal_decode_buffer_size determines how far ahead the server can look in the Write Ahead Log (WAL) to find blocks to prefetch, increasing its value would be beneficial for workloads with high prefetching requirements. 

('restore_command', 'required', 'archive recovery'): The restore_command parameter is required for archive recovery, as it specifies the local shell command to execute in order to retrieve an archived segment of the WAL file series. It should be set with the appropriate command based on the archive storage location and format.('archive_cleanup_command', 'pg_archivecleanup /mnt/server/archivedir %r', 'Used in single-standby configurations for cleaning up old archived WAL files that are no longer needed by the standby server. The %r is replaced by the name of the file containing the last valid restart point. Should not be used if multiple standby servers are restoring from the same archive directory.')('recovery_end_command', 'optional', 'used to provide a mechanism for cleanup following replication or recovery.')
('recovery_target', 'immediate', 'used to specify that recovery should end as soon as a consistent state is reached, usually when restoring from an online backup.')
('recovery_target_name', 'string', 'used to specify the named restore point to which recovery will proceed.')
('recovery_target_time', 'timestamp', 'used to specify the time stamp up to which recovery will proceed.')
