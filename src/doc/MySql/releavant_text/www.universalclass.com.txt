INNER JOIN Order AS o ON c.customer_id = o.customer_id;max_connections=341query_cache_size=9Mtable_cache=700The next variable is the "max_connections" variable. This value determines the number of users that can concurrently connect to your MySQL database. If this value is too small, you risk blocking legitimate users from using the application. However, too many concurrent users can also cause serious performance issues on the database. You should always leave extra connections if you're unsure of the amount of concurrent users needed, but don't overestimate this value too much and lose performance. The next option is "query_cache_size." This value helps speed up commonly used SELECT statements. For instance, suppose you query the same Customer and Order statement. In several parts of the application, you retrieve a list of customers with associated orders. Instead of continually querying the database files for changes, this value stores results in cache. The advantage is faster response times from the MySQL server for static data. This value can actually be a disadvantage if your table data changes often. You want to cache values that are consistently the same, but reduce the cache if your table data changes often. For instance, you wouldn't cache your audit tables since they change each time data is changed or accessed.The final variable in our example is the "table_cache" value. This value increases the number of table descriptions. Again, this value can improve performance on your tables and queries.The innodb_buffer_pool_size variable.The innodb_buffer_pool_size setting is the first one for performance tuning with InnoDB. This is the buffer pool size for data and indexes. When you cache these properties, you improve the speed at which the MySQL database can access and display data for your users. Caching stores data and indexing in memory, which is far faster that disk reads. The value you use is dependent on the size of your database. You can use a value as small as 5GB and as high as 128GB.The innodb_log_file_size variable.The max_connections variable.The innodb_flush_log_at_trx_commit variable.The innodb_flush_method variable.The innodb_log_buffer_size variable.The query_cache_size variable.The log_bin variable.Another option for purging files is to use the expire_logs_days option in your configuration files. Set this variable value to the number of days you want to keep log files. For instance, keep log files for 30 days if your corporate policy requires log files for 30 days. This value will purge files every 30 days instead of requiring you to manually purge files each month.SELECT first_name, last_name FROM CustomerWHERE first_name = ‘john' and last_name = ‘smith';This query finds every record where the first name is "John" and last name is "Smith," but if the first_name and last_name columns aren't indexes, this query is not optimized. Instead, you should use queries on indexes. The primary key on any table is an index, so instead of querying for a first and last name customer, you should query on the customer_id column. The above query would turn into the following:SELECT first_name, last_name FROM CustomerWHERE customer_id = 2;The above query would be much faster, assuming that customer_id is the primary key for the table.SELECT first_name, last_name FROM Customer AS cINNER JOIN Order AS o ON c.first_name = o.first_nameWHERE c.customer_id = 2;SELECT first_name, last_name FROM Customer AS cWHERE customer_id IN (SELECT customer_id FROM Order WHERE order.customer_id = c.customer_id);SELECT first_name, last_name FROM Customer AS cINNER JOIN Order AS o ON c.customer_id = o.customer_id;max_connections=341
query_cache_size=9M
table_cache=700
The next variable is the "max_connections" variable. This value determines the number of users that can concurrently connect to your MySQL database. If this value is too small, you risk blocking legitimate users from using the application. However, too many concurrent users can also cause serious performance issues on the database. You should always leave extra connections if you're unsure of the amount of concurrent users needed, but don't overestimate this value too much and lose performance. 
The next option is "query_cache_size." This value helps speed up commonly used SELECT statements. For instance, suppose you query the same Customer and Order statement. In several parts of the application, you retrieve a list of customers with associated orders. Instead of continually querying the database files for changes, this value stores results in cache. The advantage is faster response times from the MySQL server for static data. This value can actually be a disadvantage if your table data changes often. You want to cache values that are consistently the same, but reduce the cache if your table data changes often. For instance, you wouldn't cache your audit tables since they change each time data is changed or accessed.
The final variable in our example is the "table_cache" value. This value increases the number of table descriptions. Again, this value can improve performance on your tables and queries.
The innodb_buffer_pool_size variable.
The innodb_buffer_pool_size setting is the first one for performance tuning with InnoDB. This is the buffer pool size for data and indexes. When you cache these properties, you improve the speed at which the MySQL database can access and display data for your users. Caching stores data and indexing in memory, which is far faster that disk reads. The value you use is dependent on the size of your database. You can use a value as small as 5GB and as high as 128GB.
The innodb_log_file_size variable.
The max_connections variable.
The innodb_flush_log_at_trx_commit variable.
The innodb_flush_method variable.
The innodb_log_buffer_size variable.
The query_cache_size variable.
The log_bin variable.
Another option for purging files is to use the expire_logs_days option in your configuration files. Set this variable value to the number of days you want to keep log files. For instance, keep log files for 30 days if your corporate policy requires log files for 30 days. This value will purge files every 30 days instead of requiring you to manually purge files each month.
SELECT first_name, last_name FROM Customer
WHERE first_name = ‘john' and last_name = ‘smith';
This query finds every record where the first name is "John" and last name is "Smith," but if the first_name and last_name columns aren't indexes, this query is not optimized. Instead, you should use queries on indexes. The primary key on any table is an index, so instead of querying for a first and last name customer, you should query on the customer_id column. The above query would turn into the following:
SELECT first_name, last_name FROM Customer
WHERE customer_id = 2;
The above query would be much faster, assuming that customer_id is the primary key for the table.
SELECT first_name, last_name FROM Customer AS c
INNER JOIN Order AS o ON c.first_name = o.first_name
WHERE c.customer_id = 2;
SELECT first_name, last_name FROM Customer AS c
WHERE customer_id IN (SELECT customer_id FROM Order WHERE order.customer_id = c.customer_id);
SELECT first_name, last_name FROM Customer AS c
INNER JOIN Order AS o ON c.customer_id = o.customer_id;
